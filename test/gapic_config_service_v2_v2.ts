// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

import * as protos from '../protos/protos';
import * as assert from 'assert';
import * as sinon from 'sinon';
import {SinonStub} from 'sinon';
import {describe, it} from 'mocha';
import * as configservicev2Module from '../src';

import {PassThrough} from 'stream';

import {protobuf, LROperation, operationsProtos} from 'google-gax';

// Dynamically loaded proto JSON is needed to get the type information
// to fill in default values for request objects
const root = protobuf.Root.fromJSON(
  require('../protos/protos.json')
).resolveAll();

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function getTypeDefaultValue(typeName: string, fields: string[]) {
  let type = root.lookupType(typeName) as protobuf.Type;
  for (const field of fields.slice(0, -1)) {
    type = type.fields[field]?.resolvedType as protobuf.Type;
  }
  return type.fields[fields[fields.length - 1]]?.defaultValue;
}

function generateSampleMessage<T extends object>(instance: T) {
  const filledObject = (
    instance.constructor as typeof protobuf.Message
  ).toObject(instance as protobuf.Message<T>, {defaults: true});
  return (instance.constructor as typeof protobuf.Message).fromObject(
    filledObject
  ) as T;
}

function stubSimpleCall<ResponseType>(response?: ResponseType, error?: Error) {
  return error
    ? sinon.stub().rejects(error)
    : sinon.stub().resolves([response]);
}

function stubSimpleCallWithCallback<ResponseType>(
  response?: ResponseType,
  error?: Error
) {
  return error
    ? sinon.stub().callsArgWith(2, error)
    : sinon.stub().callsArgWith(2, null, response);
}

function stubLongRunningCall<ResponseType>(
  response?: ResponseType,
  callError?: Error,
  lroError?: Error
) {
  const innerStub = lroError
    ? sinon.stub().rejects(lroError)
    : sinon.stub().resolves([response]);
  const mockOperation = {
    promise: innerStub,
  };
  return callError
    ? sinon.stub().rejects(callError)
    : sinon.stub().resolves([mockOperation]);
}

function stubLongRunningCallWithCallback<ResponseType>(
  response?: ResponseType,
  callError?: Error,
  lroError?: Error
) {
  const innerStub = lroError
    ? sinon.stub().rejects(lroError)
    : sinon.stub().resolves([response]);
  const mockOperation = {
    promise: innerStub,
  };
  return callError
    ? sinon.stub().callsArgWith(2, callError)
    : sinon.stub().callsArgWith(2, null, mockOperation);
}

function stubPageStreamingCall<ResponseType>(
  responses?: ResponseType[],
  error?: Error
) {
  const pagingStub = sinon.stub();
  if (responses) {
    for (let i = 0; i < responses.length; ++i) {
      pagingStub.onCall(i).callsArgWith(2, null, responses[i]);
    }
  }
  const transformStub = error
    ? sinon.stub().callsArgWith(2, error)
    : pagingStub;
  const mockStream = new PassThrough({
    objectMode: true,
    transform: transformStub,
  });
  // trigger as many responses as needed
  if (responses) {
    for (let i = 0; i < responses.length; ++i) {
      setImmediate(() => {
        mockStream.write({});
      });
    }
    setImmediate(() => {
      mockStream.end();
    });
  } else {
    setImmediate(() => {
      mockStream.write({});
    });
    setImmediate(() => {
      mockStream.end();
    });
  }
  return sinon.stub().returns(mockStream);
}

function stubAsyncIterationCall<ResponseType>(
  responses?: ResponseType[],
  error?: Error
) {
  let counter = 0;
  const asyncIterable = {
    [Symbol.asyncIterator]() {
      return {
        async next() {
          if (error) {
            return Promise.reject(error);
          }
          if (counter >= responses!.length) {
            return Promise.resolve({done: true, value: undefined});
          }
          return Promise.resolve({done: false, value: responses![counter++]});
        },
      };
    },
  };
  return sinon.stub().returns(asyncIterable);
}

describe('v2.ConfigServiceV2Client', () => {
  describe('Common methods', () => {
    it('has servicePath', () => {
      const servicePath =
        configservicev2Module.v2.ConfigServiceV2Client.servicePath;
      assert(servicePath);
    });

    it('has apiEndpoint', () => {
      const apiEndpoint =
        configservicev2Module.v2.ConfigServiceV2Client.apiEndpoint;
      assert(apiEndpoint);
    });

    it('has port', () => {
      const port = configservicev2Module.v2.ConfigServiceV2Client.port;
      assert(port);
      assert(typeof port === 'number');
    });

    it('should create a client with no option', () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client();
      assert(client);
    });

    it('should create a client with gRPC fallback', () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        fallback: true,
      });
      assert(client);
    });

    it('has initialize method and supports deferred initialization', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      assert.strictEqual(client.configServiceV2Stub, undefined);
      await client.initialize();
      assert(client.configServiceV2Stub);
    });

    it('has close method for the initialized client', done => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      assert(client.configServiceV2Stub);
      client.close().then(() => {
        done();
      });
    });

    it('has close method for the non-initialized client', done => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      assert.strictEqual(client.configServiceV2Stub, undefined);
      client.close().then(() => {
        done();
      });
    });

    it('has getProjectId method', async () => {
      const fakeProjectId = 'fake-project-id';
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.auth.getProjectId = sinon.stub().resolves(fakeProjectId);
      const result = await client.getProjectId();
      assert.strictEqual(result, fakeProjectId);
      assert((client.auth.getProjectId as SinonStub).calledWithExactly());
    });

    it('has getProjectId method with callback', async () => {
      const fakeProjectId = 'fake-project-id';
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.auth.getProjectId = sinon
        .stub()
        .callsArgWith(0, null, fakeProjectId);
      const promise = new Promise((resolve, reject) => {
        client.getProjectId((err?: Error | null, projectId?: string | null) => {
          if (err) {
            reject(err);
          } else {
            resolve(projectId);
          }
        });
      });
      const result = await promise;
      assert.strictEqual(result, fakeProjectId);
    });
  });

  describe('getBucket', () => {
    it('invokes getBucket without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogBucket()
      );
      client.innerApiCalls.getBucket = stubSimpleCall(expectedResponse);
      const [response] = await client.getBucket(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getBucket without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogBucket()
      );
      client.innerApiCalls.getBucket =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getBucket(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogBucket | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getBucket with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getBucket = stubSimpleCall(undefined, expectedError);
      await assert.rejects(client.getBucket(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getBucket with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getBucket(request), expectedError);
    });
  });

  describe('createBucket', () => {
    it('invokes createBucket without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateBucketRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogBucket()
      );
      client.innerApiCalls.createBucket = stubSimpleCall(expectedResponse);
      const [response] = await client.createBucket(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createBucket without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateBucketRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogBucket()
      );
      client.innerApiCalls.createBucket =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createBucket(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogBucket | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createBucket with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateBucketRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createBucket = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createBucket(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.createBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createBucket with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateBucketRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createBucket(request), expectedError);
    });
  });

  describe('updateBucket', () => {
    it('invokes updateBucket without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogBucket()
      );
      client.innerApiCalls.updateBucket = stubSimpleCall(expectedResponse);
      const [response] = await client.updateBucket(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateBucket without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogBucket()
      );
      client.innerApiCalls.updateBucket =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateBucket(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogBucket | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateBucket with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateBucket = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateBucket(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.updateBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateBucket with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateBucket(request), expectedError);
    });
  });

  describe('deleteBucket', () => {
    it('invokes deleteBucket without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteBucket = stubSimpleCall(expectedResponse);
      const [response] = await client.deleteBucket(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteBucket without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteBucket =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteBucket(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteBucket with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteBucket = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteBucket(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.deleteBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteBucket with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteBucket(request), expectedError);
    });
  });

  describe('undeleteBucket', () => {
    it('invokes undeleteBucket without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UndeleteBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UndeleteBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.undeleteBucket = stubSimpleCall(expectedResponse);
      const [response] = await client.undeleteBucket(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.undeleteBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.undeleteBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes undeleteBucket without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UndeleteBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UndeleteBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.undeleteBucket =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.undeleteBucket(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.undeleteBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.undeleteBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes undeleteBucket with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UndeleteBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UndeleteBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.undeleteBucket = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.undeleteBucket(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.undeleteBucket as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.undeleteBucket as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes undeleteBucket with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UndeleteBucketRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UndeleteBucketRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.undeleteBucket(request), expectedError);
    });
  });

  describe('getView', () => {
    it('invokes getView without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetViewRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogView()
      );
      client.innerApiCalls.getView = stubSimpleCall(expectedResponse);
      const [response] = await client.getView(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (client.innerApiCalls.getView as SinonStub).getCall(
        0
      ).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getView as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getView without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetViewRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogView()
      );
      client.innerApiCalls.getView =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getView(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogView | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (client.innerApiCalls.getView as SinonStub).getCall(
        0
      ).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getView as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getView with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetViewRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getView = stubSimpleCall(undefined, expectedError);
      await assert.rejects(client.getView(request), expectedError);
      const actualRequest = (client.innerApiCalls.getView as SinonStub).getCall(
        0
      ).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getView as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getView with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetViewRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getView(request), expectedError);
    });
  });

  describe('createView', () => {
    it('invokes createView without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateViewRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogView()
      );
      client.innerApiCalls.createView = stubSimpleCall(expectedResponse);
      const [response] = await client.createView(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createView as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createView as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createView without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateViewRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogView()
      );
      client.innerApiCalls.createView =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createView(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogView | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createView as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createView as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createView with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateViewRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createView = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createView(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.createView as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createView as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createView with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateViewRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createView(request), expectedError);
    });
  });

  describe('updateView', () => {
    it('invokes updateView without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateViewRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogView()
      );
      client.innerApiCalls.updateView = stubSimpleCall(expectedResponse);
      const [response] = await client.updateView(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateView as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateView as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateView without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateViewRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogView()
      );
      client.innerApiCalls.updateView =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateView(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogView | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateView as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateView as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateView with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateViewRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateView = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateView(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.updateView as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateView as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateView with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateViewRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateView(request), expectedError);
    });
  });

  describe('deleteView', () => {
    it('invokes deleteView without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteViewRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteView = stubSimpleCall(expectedResponse);
      const [response] = await client.deleteView(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteView as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteView as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteView without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteViewRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteView =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteView(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteView as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteView as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteView with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteViewRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteView = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteView(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.deleteView as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteView as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteView with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteViewRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteViewRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteView(request), expectedError);
    });
  });

  describe('getSink', () => {
    it('invokes getSink without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetSinkRequest',
        ['sinkName']
      );
      request.sinkName = defaultValue1;
      const expectedHeaderRequestParams = `sink_name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogSink()
      );
      client.innerApiCalls.getSink = stubSimpleCall(expectedResponse);
      const [response] = await client.getSink(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (client.innerApiCalls.getSink as SinonStub).getCall(
        0
      ).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getSink as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getSink without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetSinkRequest',
        ['sinkName']
      );
      request.sinkName = defaultValue1;
      const expectedHeaderRequestParams = `sink_name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogSink()
      );
      client.innerApiCalls.getSink =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getSink(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogSink | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (client.innerApiCalls.getSink as SinonStub).getCall(
        0
      ).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getSink as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getSink with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetSinkRequest',
        ['sinkName']
      );
      request.sinkName = defaultValue1;
      const expectedHeaderRequestParams = `sink_name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getSink = stubSimpleCall(undefined, expectedError);
      await assert.rejects(client.getSink(request), expectedError);
      const actualRequest = (client.innerApiCalls.getSink as SinonStub).getCall(
        0
      ).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getSink as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getSink with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetSinkRequest',
        ['sinkName']
      );
      request.sinkName = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getSink(request), expectedError);
    });
  });

  describe('createSink', () => {
    it('invokes createSink without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateSinkRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogSink()
      );
      client.innerApiCalls.createSink = stubSimpleCall(expectedResponse);
      const [response] = await client.createSink(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createSink as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createSink as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createSink without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateSinkRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogSink()
      );
      client.innerApiCalls.createSink =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createSink(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogSink | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createSink as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createSink as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createSink with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateSinkRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createSink = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createSink(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.createSink as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createSink as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createSink with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateSinkRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createSink(request), expectedError);
    });
  });

  describe('updateSink', () => {
    it('invokes updateSink without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateSinkRequest',
        ['sinkName']
      );
      request.sinkName = defaultValue1;
      const expectedHeaderRequestParams = `sink_name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogSink()
      );
      client.innerApiCalls.updateSink = stubSimpleCall(expectedResponse);
      const [response] = await client.updateSink(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateSink as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateSink as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateSink without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateSinkRequest',
        ['sinkName']
      );
      request.sinkName = defaultValue1;
      const expectedHeaderRequestParams = `sink_name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogSink()
      );
      client.innerApiCalls.updateSink =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateSink(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogSink | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateSink as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateSink as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateSink with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateSinkRequest',
        ['sinkName']
      );
      request.sinkName = defaultValue1;
      const expectedHeaderRequestParams = `sink_name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateSink = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateSink(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.updateSink as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateSink as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateSink with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateSinkRequest',
        ['sinkName']
      );
      request.sinkName = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateSink(request), expectedError);
    });
  });

  describe('deleteSink', () => {
    it('invokes deleteSink without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteSinkRequest',
        ['sinkName']
      );
      request.sinkName = defaultValue1;
      const expectedHeaderRequestParams = `sink_name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteSink = stubSimpleCall(expectedResponse);
      const [response] = await client.deleteSink(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteSink as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteSink as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteSink without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteSinkRequest',
        ['sinkName']
      );
      request.sinkName = defaultValue1;
      const expectedHeaderRequestParams = `sink_name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteSink =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteSink(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteSink as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteSink as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteSink with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteSinkRequest',
        ['sinkName']
      );
      request.sinkName = defaultValue1;
      const expectedHeaderRequestParams = `sink_name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteSink = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteSink(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.deleteSink as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteSink as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteSink with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteSinkRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteSinkRequest',
        ['sinkName']
      );
      request.sinkName = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteSink(request), expectedError);
    });
  });

  describe('getExclusion', () => {
    it('invokes getExclusion without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetExclusionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogExclusion()
      );
      client.innerApiCalls.getExclusion = stubSimpleCall(expectedResponse);
      const [response] = await client.getExclusion(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getExclusion as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getExclusion as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getExclusion without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetExclusionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogExclusion()
      );
      client.innerApiCalls.getExclusion =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getExclusion(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogExclusion | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getExclusion as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getExclusion as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getExclusion with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetExclusionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getExclusion = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getExclusion(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getExclusion as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getExclusion as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getExclusion with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetExclusionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getExclusion(request), expectedError);
    });
  });

  describe('createExclusion', () => {
    it('invokes createExclusion without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateExclusionRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogExclusion()
      );
      client.innerApiCalls.createExclusion = stubSimpleCall(expectedResponse);
      const [response] = await client.createExclusion(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createExclusion as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createExclusion as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createExclusion without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateExclusionRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogExclusion()
      );
      client.innerApiCalls.createExclusion =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createExclusion(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogExclusion | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createExclusion as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createExclusion as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createExclusion with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateExclusionRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createExclusion = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createExclusion(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.createExclusion as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createExclusion as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createExclusion with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CreateExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.CreateExclusionRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createExclusion(request), expectedError);
    });
  });

  describe('updateExclusion', () => {
    it('invokes updateExclusion without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateExclusionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogExclusion()
      );
      client.innerApiCalls.updateExclusion = stubSimpleCall(expectedResponse);
      const [response] = await client.updateExclusion(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateExclusion as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateExclusion as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateExclusion without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateExclusionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.LogExclusion()
      );
      client.innerApiCalls.updateExclusion =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateExclusion(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogExclusion | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateExclusion as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateExclusion as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateExclusion with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateExclusionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateExclusion = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateExclusion(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.updateExclusion as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateExclusion as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateExclusion with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateExclusionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateExclusion(request), expectedError);
    });
  });

  describe('deleteExclusion', () => {
    it('invokes deleteExclusion without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteExclusionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteExclusion = stubSimpleCall(expectedResponse);
      const [response] = await client.deleteExclusion(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteExclusion as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteExclusion as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteExclusion without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteExclusionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteExclusion =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteExclusion(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteExclusion as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteExclusion as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteExclusion with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteExclusionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteExclusion = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteExclusion(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.deleteExclusion as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteExclusion as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteExclusion with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.DeleteExclusionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.DeleteExclusionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteExclusion(request), expectedError);
    });
  });

  describe('getCmekSettings', () => {
    it('invokes getCmekSettings without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetCmekSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetCmekSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.CmekSettings()
      );
      client.innerApiCalls.getCmekSettings = stubSimpleCall(expectedResponse);
      const [response] = await client.getCmekSettings(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getCmekSettings as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getCmekSettings as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getCmekSettings without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetCmekSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetCmekSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.CmekSettings()
      );
      client.innerApiCalls.getCmekSettings =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getCmekSettings(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ICmekSettings | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getCmekSettings as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getCmekSettings as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getCmekSettings with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetCmekSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetCmekSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getCmekSettings = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getCmekSettings(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getCmekSettings as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getCmekSettings as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getCmekSettings with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetCmekSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetCmekSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getCmekSettings(request), expectedError);
    });
  });

  describe('updateCmekSettings', () => {
    it('invokes updateCmekSettings without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateCmekSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateCmekSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.CmekSettings()
      );
      client.innerApiCalls.updateCmekSettings =
        stubSimpleCall(expectedResponse);
      const [response] = await client.updateCmekSettings(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateCmekSettings as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateCmekSettings as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateCmekSettings without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateCmekSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateCmekSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.CmekSettings()
      );
      client.innerApiCalls.updateCmekSettings =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateCmekSettings(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ICmekSettings | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateCmekSettings as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateCmekSettings as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateCmekSettings with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateCmekSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateCmekSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateCmekSettings = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateCmekSettings(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.updateCmekSettings as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateCmekSettings as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateCmekSettings with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateCmekSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateCmekSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateCmekSettings(request), expectedError);
    });
  });

  describe('getSettings', () => {
    it('invokes getSettings without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.Settings()
      );
      client.innerApiCalls.getSettings = stubSimpleCall(expectedResponse);
      const [response] = await client.getSettings(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getSettings as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getSettings as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getSettings without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.Settings()
      );
      client.innerApiCalls.getSettings =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getSettings(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ISettings | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getSettings as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getSettings as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getSettings with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getSettings = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getSettings(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getSettings as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getSettings as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getSettings with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.GetSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.GetSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getSettings(request), expectedError);
    });
  });

  describe('updateSettings', () => {
    it('invokes updateSettings without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.Settings()
      );
      client.innerApiCalls.updateSettings = stubSimpleCall(expectedResponse);
      const [response] = await client.updateSettings(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateSettings as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateSettings as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateSettings without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.logging.v2.Settings()
      );
      client.innerApiCalls.updateSettings =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateSettings(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ISettings | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateSettings as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateSettings as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateSettings with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateSettings = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateSettings(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.updateSettings as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateSettings as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateSettings with closed client', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.UpdateSettingsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.UpdateSettingsRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateSettings(request), expectedError);
    });
  });

  describe('copyLogEntries', () => {
    it('invokes copyLogEntries without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CopyLogEntriesRequest()
      );
      const expectedResponse = generateSampleMessage(
        new protos.google.longrunning.Operation()
      );
      client.innerApiCalls.copyLogEntries =
        stubLongRunningCall(expectedResponse);
      const [operation] = await client.copyLogEntries(request);
      const [response] = await operation.promise();
      assert.deepStrictEqual(response, expectedResponse);
    });

    it('invokes copyLogEntries without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CopyLogEntriesRequest()
      );
      const expectedResponse = generateSampleMessage(
        new protos.google.longrunning.Operation()
      );
      client.innerApiCalls.copyLogEntries =
        stubLongRunningCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.copyLogEntries(
          request,
          (
            err?: Error | null,
            result?: LROperation<
              protos.google.logging.v2.ICopyLogEntriesResponse,
              protos.google.logging.v2.ICopyLogEntriesMetadata
            > | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const operation = (await promise) as LROperation<
        protos.google.logging.v2.ICopyLogEntriesResponse,
        protos.google.logging.v2.ICopyLogEntriesMetadata
      >;
      const [response] = await operation.promise();
      assert.deepStrictEqual(response, expectedResponse);
    });

    it('invokes copyLogEntries with call error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CopyLogEntriesRequest()
      );
      const expectedError = new Error('expected');
      client.innerApiCalls.copyLogEntries = stubLongRunningCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.copyLogEntries(request), expectedError);
    });

    it('invokes copyLogEntries with LRO error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.CopyLogEntriesRequest()
      );
      const expectedError = new Error('expected');
      client.innerApiCalls.copyLogEntries = stubLongRunningCall(
        undefined,
        undefined,
        expectedError
      );
      const [operation] = await client.copyLogEntries(request);
      await assert.rejects(operation.promise(), expectedError);
    });

    it('invokes checkCopyLogEntriesProgress without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const expectedResponse = generateSampleMessage(
        new operationsProtos.google.longrunning.Operation()
      );
      expectedResponse.name = 'test';
      expectedResponse.response = {type_url: 'url', value: Buffer.from('')};
      expectedResponse.metadata = {type_url: 'url', value: Buffer.from('')};

      client.operationsClient.getOperation = stubSimpleCall(expectedResponse);
      const decodedOperation = await client.checkCopyLogEntriesProgress(
        expectedResponse.name
      );
      assert.deepStrictEqual(decodedOperation.name, expectedResponse.name);
      assert(decodedOperation.metadata);
      assert((client.operationsClient.getOperation as SinonStub).getCall(0));
    });

    it('invokes checkCopyLogEntriesProgress with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const expectedError = new Error('expected');

      client.operationsClient.getOperation = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.checkCopyLogEntriesProgress(''),
        expectedError
      );
      assert((client.operationsClient.getOperation as SinonStub).getCall(0));
    });
  });

  describe('listBuckets', () => {
    it('invokes listBuckets without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListBucketsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListBucketsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogBucket()),
        generateSampleMessage(new protos.google.logging.v2.LogBucket()),
        generateSampleMessage(new protos.google.logging.v2.LogBucket()),
      ];
      client.innerApiCalls.listBuckets = stubSimpleCall(expectedResponse);
      const [response] = await client.listBuckets(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listBuckets as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listBuckets as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listBuckets without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListBucketsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListBucketsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogBucket()),
        generateSampleMessage(new protos.google.logging.v2.LogBucket()),
        generateSampleMessage(new protos.google.logging.v2.LogBucket()),
      ];
      client.innerApiCalls.listBuckets =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listBuckets(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogBucket[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listBuckets as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listBuckets as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listBuckets with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListBucketsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListBucketsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listBuckets = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listBuckets(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listBuckets as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listBuckets as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listBucketsStream without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListBucketsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListBucketsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogBucket()),
        generateSampleMessage(new protos.google.logging.v2.LogBucket()),
        generateSampleMessage(new protos.google.logging.v2.LogBucket()),
      ];
      client.descriptors.page.listBuckets.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listBucketsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.logging.v2.LogBucket[] = [];
        stream.on('data', (response: protos.google.logging.v2.LogBucket) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listBuckets.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listBuckets, request)
      );
      assert(
        (client.descriptors.page.listBuckets.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('invokes listBucketsStream with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListBucketsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListBucketsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listBuckets.createStream = stubPageStreamingCall(
        undefined,
        expectedError
      );
      const stream = client.listBucketsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.logging.v2.LogBucket[] = [];
        stream.on('data', (response: protos.google.logging.v2.LogBucket) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listBuckets.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listBuckets, request)
      );
      assert(
        (client.descriptors.page.listBuckets.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listBuckets without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListBucketsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListBucketsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogBucket()),
        generateSampleMessage(new protos.google.logging.v2.LogBucket()),
        generateSampleMessage(new protos.google.logging.v2.LogBucket()),
      ];
      client.descriptors.page.listBuckets.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.logging.v2.ILogBucket[] = [];
      const iterable = client.listBucketsAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (client.descriptors.page.listBuckets.asyncIterate as SinonStub).getCall(
          0
        ).args[1],
        request
      );
      assert(
        (client.descriptors.page.listBuckets.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listBuckets with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListBucketsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListBucketsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listBuckets.asyncIterate = stubAsyncIterationCall(
        undefined,
        expectedError
      );
      const iterable = client.listBucketsAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.logging.v2.ILogBucket[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (client.descriptors.page.listBuckets.asyncIterate as SinonStub).getCall(
          0
        ).args[1],
        request
      );
      assert(
        (client.descriptors.page.listBuckets.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });
  });

  describe('listViews', () => {
    it('invokes listViews without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListViewsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListViewsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogView()),
        generateSampleMessage(new protos.google.logging.v2.LogView()),
        generateSampleMessage(new protos.google.logging.v2.LogView()),
      ];
      client.innerApiCalls.listViews = stubSimpleCall(expectedResponse);
      const [response] = await client.listViews(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listViews as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listViews as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listViews without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListViewsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListViewsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogView()),
        generateSampleMessage(new protos.google.logging.v2.LogView()),
        generateSampleMessage(new protos.google.logging.v2.LogView()),
      ];
      client.innerApiCalls.listViews =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listViews(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogView[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listViews as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listViews as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listViews with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListViewsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListViewsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listViews = stubSimpleCall(undefined, expectedError);
      await assert.rejects(client.listViews(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listViews as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listViews as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listViewsStream without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListViewsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListViewsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogView()),
        generateSampleMessage(new protos.google.logging.v2.LogView()),
        generateSampleMessage(new protos.google.logging.v2.LogView()),
      ];
      client.descriptors.page.listViews.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listViewsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.logging.v2.LogView[] = [];
        stream.on('data', (response: protos.google.logging.v2.LogView) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listViews.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listViews, request)
      );
      assert(
        (client.descriptors.page.listViews.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('invokes listViewsStream with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListViewsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListViewsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listViews.createStream = stubPageStreamingCall(
        undefined,
        expectedError
      );
      const stream = client.listViewsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.logging.v2.LogView[] = [];
        stream.on('data', (response: protos.google.logging.v2.LogView) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listViews.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listViews, request)
      );
      assert(
        (client.descriptors.page.listViews.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listViews without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListViewsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListViewsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogView()),
        generateSampleMessage(new protos.google.logging.v2.LogView()),
        generateSampleMessage(new protos.google.logging.v2.LogView()),
      ];
      client.descriptors.page.listViews.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.logging.v2.ILogView[] = [];
      const iterable = client.listViewsAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (client.descriptors.page.listViews.asyncIterate as SinonStub).getCall(0)
          .args[1],
        request
      );
      assert(
        (client.descriptors.page.listViews.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listViews with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListViewsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListViewsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listViews.asyncIterate = stubAsyncIterationCall(
        undefined,
        expectedError
      );
      const iterable = client.listViewsAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.logging.v2.ILogView[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (client.descriptors.page.listViews.asyncIterate as SinonStub).getCall(0)
          .args[1],
        request
      );
      assert(
        (client.descriptors.page.listViews.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });
  });

  describe('listSinks', () => {
    it('invokes listSinks without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListSinksRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListSinksRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogSink()),
        generateSampleMessage(new protos.google.logging.v2.LogSink()),
        generateSampleMessage(new protos.google.logging.v2.LogSink()),
      ];
      client.innerApiCalls.listSinks = stubSimpleCall(expectedResponse);
      const [response] = await client.listSinks(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listSinks as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listSinks as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listSinks without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListSinksRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListSinksRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogSink()),
        generateSampleMessage(new protos.google.logging.v2.LogSink()),
        generateSampleMessage(new protos.google.logging.v2.LogSink()),
      ];
      client.innerApiCalls.listSinks =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listSinks(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogSink[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listSinks as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listSinks as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listSinks with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListSinksRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListSinksRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listSinks = stubSimpleCall(undefined, expectedError);
      await assert.rejects(client.listSinks(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listSinks as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listSinks as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listSinksStream without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListSinksRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListSinksRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogSink()),
        generateSampleMessage(new protos.google.logging.v2.LogSink()),
        generateSampleMessage(new protos.google.logging.v2.LogSink()),
      ];
      client.descriptors.page.listSinks.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listSinksStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.logging.v2.LogSink[] = [];
        stream.on('data', (response: protos.google.logging.v2.LogSink) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listSinks.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listSinks, request)
      );
      assert(
        (client.descriptors.page.listSinks.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('invokes listSinksStream with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListSinksRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListSinksRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listSinks.createStream = stubPageStreamingCall(
        undefined,
        expectedError
      );
      const stream = client.listSinksStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.logging.v2.LogSink[] = [];
        stream.on('data', (response: protos.google.logging.v2.LogSink) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listSinks.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listSinks, request)
      );
      assert(
        (client.descriptors.page.listSinks.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listSinks without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListSinksRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListSinksRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogSink()),
        generateSampleMessage(new protos.google.logging.v2.LogSink()),
        generateSampleMessage(new protos.google.logging.v2.LogSink()),
      ];
      client.descriptors.page.listSinks.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.logging.v2.ILogSink[] = [];
      const iterable = client.listSinksAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (client.descriptors.page.listSinks.asyncIterate as SinonStub).getCall(0)
          .args[1],
        request
      );
      assert(
        (client.descriptors.page.listSinks.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listSinks with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListSinksRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListSinksRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listSinks.asyncIterate = stubAsyncIterationCall(
        undefined,
        expectedError
      );
      const iterable = client.listSinksAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.logging.v2.ILogSink[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (client.descriptors.page.listSinks.asyncIterate as SinonStub).getCall(0)
          .args[1],
        request
      );
      assert(
        (client.descriptors.page.listSinks.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });
  });

  describe('listExclusions', () => {
    it('invokes listExclusions without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListExclusionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListExclusionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogExclusion()),
        generateSampleMessage(new protos.google.logging.v2.LogExclusion()),
        generateSampleMessage(new protos.google.logging.v2.LogExclusion()),
      ];
      client.innerApiCalls.listExclusions = stubSimpleCall(expectedResponse);
      const [response] = await client.listExclusions(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listExclusions as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listExclusions as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listExclusions without error using callback', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListExclusionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListExclusionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogExclusion()),
        generateSampleMessage(new protos.google.logging.v2.LogExclusion()),
        generateSampleMessage(new protos.google.logging.v2.LogExclusion()),
      ];
      client.innerApiCalls.listExclusions =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listExclusions(
          request,
          (
            err?: Error | null,
            result?: protos.google.logging.v2.ILogExclusion[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listExclusions as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listExclusions as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listExclusions with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListExclusionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListExclusionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listExclusions = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listExclusions(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listExclusions as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listExclusions as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listExclusionsStream without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListExclusionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListExclusionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogExclusion()),
        generateSampleMessage(new protos.google.logging.v2.LogExclusion()),
        generateSampleMessage(new protos.google.logging.v2.LogExclusion()),
      ];
      client.descriptors.page.listExclusions.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listExclusionsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.logging.v2.LogExclusion[] = [];
        stream.on('data', (response: protos.google.logging.v2.LogExclusion) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listExclusions.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listExclusions, request)
      );
      assert(
        (client.descriptors.page.listExclusions.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('invokes listExclusionsStream with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListExclusionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListExclusionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listExclusions.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listExclusionsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.logging.v2.LogExclusion[] = [];
        stream.on('data', (response: protos.google.logging.v2.LogExclusion) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listExclusions.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listExclusions, request)
      );
      assert(
        (client.descriptors.page.listExclusions.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listExclusions without error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListExclusionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListExclusionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.logging.v2.LogExclusion()),
        generateSampleMessage(new protos.google.logging.v2.LogExclusion()),
        generateSampleMessage(new protos.google.logging.v2.LogExclusion()),
      ];
      client.descriptors.page.listExclusions.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.logging.v2.ILogExclusion[] = [];
      const iterable = client.listExclusionsAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listExclusions.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listExclusions.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listExclusions with error', async () => {
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.logging.v2.ListExclusionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.logging.v2.ListExclusionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listExclusions.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listExclusionsAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.logging.v2.ILogExclusion[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listExclusions.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listExclusions.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });
  });

  describe('Path templates', () => {
    describe('billingAccountCmekSettings', () => {
      const fakePath = '/rendered/path/billingAccountCmekSettings';
      const expectedParameters = {
        billing_account: 'billingAccountValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.billingAccountCmekSettingsPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.billingAccountCmekSettingsPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('billingAccountCmekSettingsPath', () => {
        const result = client.billingAccountCmekSettingsPath(
          'billingAccountValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.billingAccountCmekSettingsPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchBillingAccountFromBillingAccountCmekSettingsName', () => {
        const result =
          client.matchBillingAccountFromBillingAccountCmekSettingsName(
            fakePath
          );
        assert.strictEqual(result, 'billingAccountValue');
        assert(
          (
            client.pathTemplates.billingAccountCmekSettingsPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('billingAccountExclusion', () => {
      const fakePath = '/rendered/path/billingAccountExclusion';
      const expectedParameters = {
        billing_account: 'billingAccountValue',
        exclusion: 'exclusionValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.billingAccountExclusionPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.billingAccountExclusionPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('billingAccountExclusionPath', () => {
        const result = client.billingAccountExclusionPath(
          'billingAccountValue',
          'exclusionValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.billingAccountExclusionPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchBillingAccountFromBillingAccountExclusionName', () => {
        const result =
          client.matchBillingAccountFromBillingAccountExclusionName(fakePath);
        assert.strictEqual(result, 'billingAccountValue');
        assert(
          (
            client.pathTemplates.billingAccountExclusionPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchExclusionFromBillingAccountExclusionName', () => {
        const result =
          client.matchExclusionFromBillingAccountExclusionName(fakePath);
        assert.strictEqual(result, 'exclusionValue');
        assert(
          (
            client.pathTemplates.billingAccountExclusionPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('billingAccountLocationBucket', () => {
      const fakePath = '/rendered/path/billingAccountLocationBucket';
      const expectedParameters = {
        billing_account: 'billingAccountValue',
        location: 'locationValue',
        bucket: 'bucketValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.billingAccountLocationBucketPathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.billingAccountLocationBucketPathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('billingAccountLocationBucketPath', () => {
        const result = client.billingAccountLocationBucketPath(
          'billingAccountValue',
          'locationValue',
          'bucketValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.billingAccountLocationBucketPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchBillingAccountFromBillingAccountLocationBucketName', () => {
        const result =
          client.matchBillingAccountFromBillingAccountLocationBucketName(
            fakePath
          );
        assert.strictEqual(result, 'billingAccountValue');
        assert(
          (
            client.pathTemplates.billingAccountLocationBucketPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromBillingAccountLocationBucketName', () => {
        const result =
          client.matchLocationFromBillingAccountLocationBucketName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.billingAccountLocationBucketPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchBucketFromBillingAccountLocationBucketName', () => {
        const result =
          client.matchBucketFromBillingAccountLocationBucketName(fakePath);
        assert.strictEqual(result, 'bucketValue');
        assert(
          (
            client.pathTemplates.billingAccountLocationBucketPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('billingAccountLocationBucketView', () => {
      const fakePath = '/rendered/path/billingAccountLocationBucketView';
      const expectedParameters = {
        billing_account: 'billingAccountValue',
        location: 'locationValue',
        bucket: 'bucketValue',
        view: 'viewValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.billingAccountLocationBucketViewPathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.billingAccountLocationBucketViewPathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('billingAccountLocationBucketViewPath', () => {
        const result = client.billingAccountLocationBucketViewPath(
          'billingAccountValue',
          'locationValue',
          'bucketValue',
          'viewValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.billingAccountLocationBucketViewPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchBillingAccountFromBillingAccountLocationBucketViewName', () => {
        const result =
          client.matchBillingAccountFromBillingAccountLocationBucketViewName(
            fakePath
          );
        assert.strictEqual(result, 'billingAccountValue');
        assert(
          (
            client.pathTemplates.billingAccountLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromBillingAccountLocationBucketViewName', () => {
        const result =
          client.matchLocationFromBillingAccountLocationBucketViewName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.billingAccountLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchBucketFromBillingAccountLocationBucketViewName', () => {
        const result =
          client.matchBucketFromBillingAccountLocationBucketViewName(fakePath);
        assert.strictEqual(result, 'bucketValue');
        assert(
          (
            client.pathTemplates.billingAccountLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchViewFromBillingAccountLocationBucketViewName', () => {
        const result =
          client.matchViewFromBillingAccountLocationBucketViewName(fakePath);
        assert.strictEqual(result, 'viewValue');
        assert(
          (
            client.pathTemplates.billingAccountLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('billingAccountLog', () => {
      const fakePath = '/rendered/path/billingAccountLog';
      const expectedParameters = {
        billing_account: 'billingAccountValue',
        log: 'logValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.billingAccountLogPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.billingAccountLogPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('billingAccountLogPath', () => {
        const result = client.billingAccountLogPath(
          'billingAccountValue',
          'logValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.billingAccountLogPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchBillingAccountFromBillingAccountLogName', () => {
        const result =
          client.matchBillingAccountFromBillingAccountLogName(fakePath);
        assert.strictEqual(result, 'billingAccountValue');
        assert(
          (
            client.pathTemplates.billingAccountLogPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLogFromBillingAccountLogName', () => {
        const result = client.matchLogFromBillingAccountLogName(fakePath);
        assert.strictEqual(result, 'logValue');
        assert(
          (
            client.pathTemplates.billingAccountLogPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('billingAccountSettings', () => {
      const fakePath = '/rendered/path/billingAccountSettings';
      const expectedParameters = {
        billing_account: 'billingAccountValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.billingAccountSettingsPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.billingAccountSettingsPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('billingAccountSettingsPath', () => {
        const result = client.billingAccountSettingsPath('billingAccountValue');
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.billingAccountSettingsPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchBillingAccountFromBillingAccountSettingsName', () => {
        const result =
          client.matchBillingAccountFromBillingAccountSettingsName(fakePath);
        assert.strictEqual(result, 'billingAccountValue');
        assert(
          (
            client.pathTemplates.billingAccountSettingsPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('billingAccountSink', () => {
      const fakePath = '/rendered/path/billingAccountSink';
      const expectedParameters = {
        billing_account: 'billingAccountValue',
        sink: 'sinkValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.billingAccountSinkPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.billingAccountSinkPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('billingAccountSinkPath', () => {
        const result = client.billingAccountSinkPath(
          'billingAccountValue',
          'sinkValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.billingAccountSinkPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchBillingAccountFromBillingAccountSinkName', () => {
        const result =
          client.matchBillingAccountFromBillingAccountSinkName(fakePath);
        assert.strictEqual(result, 'billingAccountValue');
        assert(
          (
            client.pathTemplates.billingAccountSinkPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchSinkFromBillingAccountSinkName', () => {
        const result = client.matchSinkFromBillingAccountSinkName(fakePath);
        assert.strictEqual(result, 'sinkValue');
        assert(
          (
            client.pathTemplates.billingAccountSinkPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('folderCmekSettings', () => {
      const fakePath = '/rendered/path/folderCmekSettings';
      const expectedParameters = {
        folder: 'folderValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.folderCmekSettingsPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.folderCmekSettingsPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('folderCmekSettingsPath', () => {
        const result = client.folderCmekSettingsPath('folderValue');
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.folderCmekSettingsPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchFolderFromFolderCmekSettingsName', () => {
        const result = client.matchFolderFromFolderCmekSettingsName(fakePath);
        assert.strictEqual(result, 'folderValue');
        assert(
          (
            client.pathTemplates.folderCmekSettingsPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('folderExclusion', () => {
      const fakePath = '/rendered/path/folderExclusion';
      const expectedParameters = {
        folder: 'folderValue',
        exclusion: 'exclusionValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.folderExclusionPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.folderExclusionPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('folderExclusionPath', () => {
        const result = client.folderExclusionPath(
          'folderValue',
          'exclusionValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.folderExclusionPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchFolderFromFolderExclusionName', () => {
        const result = client.matchFolderFromFolderExclusionName(fakePath);
        assert.strictEqual(result, 'folderValue');
        assert(
          (client.pathTemplates.folderExclusionPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchExclusionFromFolderExclusionName', () => {
        const result = client.matchExclusionFromFolderExclusionName(fakePath);
        assert.strictEqual(result, 'exclusionValue');
        assert(
          (client.pathTemplates.folderExclusionPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('folderLocationBucket', () => {
      const fakePath = '/rendered/path/folderLocationBucket';
      const expectedParameters = {
        folder: 'folderValue',
        location: 'locationValue',
        bucket: 'bucketValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.folderLocationBucketPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.folderLocationBucketPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('folderLocationBucketPath', () => {
        const result = client.folderLocationBucketPath(
          'folderValue',
          'locationValue',
          'bucketValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.folderLocationBucketPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchFolderFromFolderLocationBucketName', () => {
        const result = client.matchFolderFromFolderLocationBucketName(fakePath);
        assert.strictEqual(result, 'folderValue');
        assert(
          (
            client.pathTemplates.folderLocationBucketPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromFolderLocationBucketName', () => {
        const result =
          client.matchLocationFromFolderLocationBucketName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.folderLocationBucketPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchBucketFromFolderLocationBucketName', () => {
        const result = client.matchBucketFromFolderLocationBucketName(fakePath);
        assert.strictEqual(result, 'bucketValue');
        assert(
          (
            client.pathTemplates.folderLocationBucketPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('folderLocationBucketView', () => {
      const fakePath = '/rendered/path/folderLocationBucketView';
      const expectedParameters = {
        folder: 'folderValue',
        location: 'locationValue',
        bucket: 'bucketValue',
        view: 'viewValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.folderLocationBucketViewPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.folderLocationBucketViewPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('folderLocationBucketViewPath', () => {
        const result = client.folderLocationBucketViewPath(
          'folderValue',
          'locationValue',
          'bucketValue',
          'viewValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.folderLocationBucketViewPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchFolderFromFolderLocationBucketViewName', () => {
        const result =
          client.matchFolderFromFolderLocationBucketViewName(fakePath);
        assert.strictEqual(result, 'folderValue');
        assert(
          (
            client.pathTemplates.folderLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromFolderLocationBucketViewName', () => {
        const result =
          client.matchLocationFromFolderLocationBucketViewName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.folderLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchBucketFromFolderLocationBucketViewName', () => {
        const result =
          client.matchBucketFromFolderLocationBucketViewName(fakePath);
        assert.strictEqual(result, 'bucketValue');
        assert(
          (
            client.pathTemplates.folderLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchViewFromFolderLocationBucketViewName', () => {
        const result =
          client.matchViewFromFolderLocationBucketViewName(fakePath);
        assert.strictEqual(result, 'viewValue');
        assert(
          (
            client.pathTemplates.folderLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('folderLog', () => {
      const fakePath = '/rendered/path/folderLog';
      const expectedParameters = {
        folder: 'folderValue',
        log: 'logValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.folderLogPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.folderLogPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('folderLogPath', () => {
        const result = client.folderLogPath('folderValue', 'logValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.folderLogPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchFolderFromFolderLogName', () => {
        const result = client.matchFolderFromFolderLogName(fakePath);
        assert.strictEqual(result, 'folderValue');
        assert(
          (client.pathTemplates.folderLogPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLogFromFolderLogName', () => {
        const result = client.matchLogFromFolderLogName(fakePath);
        assert.strictEqual(result, 'logValue');
        assert(
          (client.pathTemplates.folderLogPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('folderSettings', () => {
      const fakePath = '/rendered/path/folderSettings';
      const expectedParameters = {
        folder: 'folderValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.folderSettingsPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.folderSettingsPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('folderSettingsPath', () => {
        const result = client.folderSettingsPath('folderValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.folderSettingsPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchFolderFromFolderSettingsName', () => {
        const result = client.matchFolderFromFolderSettingsName(fakePath);
        assert.strictEqual(result, 'folderValue');
        assert(
          (client.pathTemplates.folderSettingsPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('folderSink', () => {
      const fakePath = '/rendered/path/folderSink';
      const expectedParameters = {
        folder: 'folderValue',
        sink: 'sinkValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.folderSinkPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.folderSinkPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('folderSinkPath', () => {
        const result = client.folderSinkPath('folderValue', 'sinkValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.folderSinkPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchFolderFromFolderSinkName', () => {
        const result = client.matchFolderFromFolderSinkName(fakePath);
        assert.strictEqual(result, 'folderValue');
        assert(
          (client.pathTemplates.folderSinkPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchSinkFromFolderSinkName', () => {
        const result = client.matchSinkFromFolderSinkName(fakePath);
        assert.strictEqual(result, 'sinkValue');
        assert(
          (client.pathTemplates.folderSinkPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('location', () => {
      const fakePath = '/rendered/path/location';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.locationPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.locationPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('locationPath', () => {
        const result = client.locationPath('projectValue', 'locationValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.locationPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromLocationName', () => {
        const result = client.matchProjectFromLocationName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.locationPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromLocationName', () => {
        const result = client.matchLocationFromLocationName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (client.pathTemplates.locationPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('logMetric', () => {
      const fakePath = '/rendered/path/logMetric';
      const expectedParameters = {
        project: 'projectValue',
        metric: 'metricValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.logMetricPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.logMetricPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('logMetricPath', () => {
        const result = client.logMetricPath('projectValue', 'metricValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.logMetricPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromLogMetricName', () => {
        const result = client.matchProjectFromLogMetricName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.logMetricPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchMetricFromLogMetricName', () => {
        const result = client.matchMetricFromLogMetricName(fakePath);
        assert.strictEqual(result, 'metricValue');
        assert(
          (client.pathTemplates.logMetricPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationCmekSettings', () => {
      const fakePath = '/rendered/path/organizationCmekSettings';
      const expectedParameters = {
        organization: 'organizationValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationCmekSettingsPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.organizationCmekSettingsPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('organizationCmekSettingsPath', () => {
        const result = client.organizationCmekSettingsPath('organizationValue');
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationCmekSettingsPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationCmekSettingsName', () => {
        const result =
          client.matchOrganizationFromOrganizationCmekSettingsName(fakePath);
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationCmekSettingsPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationExclusion', () => {
      const fakePath = '/rendered/path/organizationExclusion';
      const expectedParameters = {
        organization: 'organizationValue',
        exclusion: 'exclusionValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationExclusionPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.organizationExclusionPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('organizationExclusionPath', () => {
        const result = client.organizationExclusionPath(
          'organizationValue',
          'exclusionValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationExclusionPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationExclusionName', () => {
        const result =
          client.matchOrganizationFromOrganizationExclusionName(fakePath);
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationExclusionPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchExclusionFromOrganizationExclusionName', () => {
        const result =
          client.matchExclusionFromOrganizationExclusionName(fakePath);
        assert.strictEqual(result, 'exclusionValue');
        assert(
          (
            client.pathTemplates.organizationExclusionPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocationBucket', () => {
      const fakePath = '/rendered/path/organizationLocationBucket';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
        bucket: 'bucketValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationBucketPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.organizationLocationBucketPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('organizationLocationBucketPath', () => {
        const result = client.organizationLocationBucketPath(
          'organizationValue',
          'locationValue',
          'bucketValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationLocationBucketPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationBucketName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationBucketName(fakePath);
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationLocationBucketPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationBucketName', () => {
        const result =
          client.matchLocationFromOrganizationLocationBucketName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.organizationLocationBucketPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchBucketFromOrganizationLocationBucketName', () => {
        const result =
          client.matchBucketFromOrganizationLocationBucketName(fakePath);
        assert.strictEqual(result, 'bucketValue');
        assert(
          (
            client.pathTemplates.organizationLocationBucketPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocationBucketView', () => {
      const fakePath = '/rendered/path/organizationLocationBucketView';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
        bucket: 'bucketValue',
        view: 'viewValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationBucketViewPathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationLocationBucketViewPathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationLocationBucketViewPath', () => {
        const result = client.organizationLocationBucketViewPath(
          'organizationValue',
          'locationValue',
          'bucketValue',
          'viewValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationLocationBucketViewPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationBucketViewName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationBucketViewName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationBucketViewName', () => {
        const result =
          client.matchLocationFromOrganizationLocationBucketViewName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.organizationLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchBucketFromOrganizationLocationBucketViewName', () => {
        const result =
          client.matchBucketFromOrganizationLocationBucketViewName(fakePath);
        assert.strictEqual(result, 'bucketValue');
        assert(
          (
            client.pathTemplates.organizationLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchViewFromOrganizationLocationBucketViewName', () => {
        const result =
          client.matchViewFromOrganizationLocationBucketViewName(fakePath);
        assert.strictEqual(result, 'viewValue');
        assert(
          (
            client.pathTemplates.organizationLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLog', () => {
      const fakePath = '/rendered/path/organizationLog';
      const expectedParameters = {
        organization: 'organizationValue',
        log: 'logValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLogPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.organizationLogPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('organizationLogPath', () => {
        const result = client.organizationLogPath(
          'organizationValue',
          'logValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.organizationLogPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLogName', () => {
        const result =
          client.matchOrganizationFromOrganizationLogName(fakePath);
        assert.strictEqual(result, 'organizationValue');
        assert(
          (client.pathTemplates.organizationLogPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLogFromOrganizationLogName', () => {
        const result = client.matchLogFromOrganizationLogName(fakePath);
        assert.strictEqual(result, 'logValue');
        assert(
          (client.pathTemplates.organizationLogPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationSettings', () => {
      const fakePath = '/rendered/path/organizationSettings';
      const expectedParameters = {
        organization: 'organizationValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationSettingsPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.organizationSettingsPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('organizationSettingsPath', () => {
        const result = client.organizationSettingsPath('organizationValue');
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationSettingsPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationSettingsName', () => {
        const result =
          client.matchOrganizationFromOrganizationSettingsName(fakePath);
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationSettingsPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationSink', () => {
      const fakePath = '/rendered/path/organizationSink';
      const expectedParameters = {
        organization: 'organizationValue',
        sink: 'sinkValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationSinkPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.organizationSinkPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('organizationSinkPath', () => {
        const result = client.organizationSinkPath(
          'organizationValue',
          'sinkValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationSinkPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationSinkName', () => {
        const result =
          client.matchOrganizationFromOrganizationSinkName(fakePath);
        assert.strictEqual(result, 'organizationValue');
        assert(
          (client.pathTemplates.organizationSinkPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchSinkFromOrganizationSinkName', () => {
        const result = client.matchSinkFromOrganizationSinkName(fakePath);
        assert.strictEqual(result, 'sinkValue');
        assert(
          (client.pathTemplates.organizationSinkPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('project', () => {
      const fakePath = '/rendered/path/project';
      const expectedParameters = {
        project: 'projectValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectPath', () => {
        const result = client.projectPath('projectValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.projectPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectName', () => {
        const result = client.matchProjectFromProjectName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.projectPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectCmekSettings', () => {
      const fakePath = '/rendered/path/projectCmekSettings';
      const expectedParameters = {
        project: 'projectValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectCmekSettingsPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectCmekSettingsPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectCmekSettingsPath', () => {
        const result = client.projectCmekSettingsPath('projectValue');
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectCmekSettingsPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectCmekSettingsName', () => {
        const result = client.matchProjectFromProjectCmekSettingsName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectCmekSettingsPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectExclusion', () => {
      const fakePath = '/rendered/path/projectExclusion';
      const expectedParameters = {
        project: 'projectValue',
        exclusion: 'exclusionValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectExclusionPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectExclusionPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectExclusionPath', () => {
        const result = client.projectExclusionPath(
          'projectValue',
          'exclusionValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectExclusionPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectExclusionName', () => {
        const result = client.matchProjectFromProjectExclusionName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.projectExclusionPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchExclusionFromProjectExclusionName', () => {
        const result = client.matchExclusionFromProjectExclusionName(fakePath);
        assert.strictEqual(result, 'exclusionValue');
        assert(
          (client.pathTemplates.projectExclusionPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationBucket', () => {
      const fakePath = '/rendered/path/projectLocationBucket';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        bucket: 'bucketValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationBucketPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectLocationBucketPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectLocationBucketPath', () => {
        const result = client.projectLocationBucketPath(
          'projectValue',
          'locationValue',
          'bucketValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationBucketPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationBucketName', () => {
        const result =
          client.matchProjectFromProjectLocationBucketName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationBucketPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationBucketName', () => {
        const result =
          client.matchLocationFromProjectLocationBucketName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationBucketPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchBucketFromProjectLocationBucketName', () => {
        const result =
          client.matchBucketFromProjectLocationBucketName(fakePath);
        assert.strictEqual(result, 'bucketValue');
        assert(
          (
            client.pathTemplates.projectLocationBucketPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationBucketView', () => {
      const fakePath = '/rendered/path/projectLocationBucketView';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        bucket: 'bucketValue',
        view: 'viewValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationBucketViewPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectLocationBucketViewPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectLocationBucketViewPath', () => {
        const result = client.projectLocationBucketViewPath(
          'projectValue',
          'locationValue',
          'bucketValue',
          'viewValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationBucketViewPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationBucketViewName', () => {
        const result =
          client.matchProjectFromProjectLocationBucketViewName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationBucketViewName', () => {
        const result =
          client.matchLocationFromProjectLocationBucketViewName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchBucketFromProjectLocationBucketViewName', () => {
        const result =
          client.matchBucketFromProjectLocationBucketViewName(fakePath);
        assert.strictEqual(result, 'bucketValue');
        assert(
          (
            client.pathTemplates.projectLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchViewFromProjectLocationBucketViewName', () => {
        const result =
          client.matchViewFromProjectLocationBucketViewName(fakePath);
        assert.strictEqual(result, 'viewValue');
        assert(
          (
            client.pathTemplates.projectLocationBucketViewPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLog', () => {
      const fakePath = '/rendered/path/projectLog';
      const expectedParameters = {
        project: 'projectValue',
        log: 'logValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLogPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectLogPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectLogPath', () => {
        const result = client.projectLogPath('projectValue', 'logValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.projectLogPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLogName', () => {
        const result = client.matchProjectFromProjectLogName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.projectLogPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLogFromProjectLogName', () => {
        const result = client.matchLogFromProjectLogName(fakePath);
        assert.strictEqual(result, 'logValue');
        assert(
          (client.pathTemplates.projectLogPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectSettings', () => {
      const fakePath = '/rendered/path/projectSettings';
      const expectedParameters = {
        project: 'projectValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectSettingsPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectSettingsPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectSettingsPath', () => {
        const result = client.projectSettingsPath('projectValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.projectSettingsPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectSettingsName', () => {
        const result = client.matchProjectFromProjectSettingsName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.projectSettingsPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectSink', () => {
      const fakePath = '/rendered/path/projectSink';
      const expectedParameters = {
        project: 'projectValue',
        sink: 'sinkValue',
      };
      const client = new configservicev2Module.v2.ConfigServiceV2Client({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectSinkPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectSinkPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectSinkPath', () => {
        const result = client.projectSinkPath('projectValue', 'sinkValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.projectSinkPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectSinkName', () => {
        const result = client.matchProjectFromProjectSinkName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.projectSinkPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchSinkFromProjectSinkName', () => {
        const result = client.matchSinkFromProjectSinkName(fakePath);
        assert.strictEqual(result, 'sinkValue');
        assert(
          (client.pathTemplates.projectSinkPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });
  });
});
